"""
File: osc2osm.py
Created by: Jeffrey Meyers
Email: jeffrey dot meyers at pdx dot edu
Created on: 10/4/2013
Modified: 10/4/2013

This file contains functions used to convert an openstreetmap change file
generated by osmosis into an osm file to be viewed in an editor such as josm.

The output will be an osm file containing an additional 'change' tag specifying if that
object was created, modified, or deleted. You have the option of including a
new line seperated list of usernames you would like to remove from the final output.
Any object that is created or modified by these users will not show up, but features
deleted by these users will still be present.

Some inputs required to use these functions are a change file and the old osm file
used to create the change file. A change file can be generated using the example below.

  ex: osmosis -q --rx new_file.osm --rx old_file.osm --dc --wxc change_file.osc


Note: relation changes are not currently working

"""

# TODO 

# check Build function for necessity of looping over old tree for 
#modified and deleted nodes/ways 

# TODO

# implement as standalone command line tool with arguments 
#to be ran independently from change2osm.py

import urllib2
import sys
from xml.etree import cElementTree as ElementTree
from xml.etree.cElementTree import Element

# Function Identify(change_file, users)
#
# in: change_file.osc generated from osmosis, optional new line seperated list of users to ignore
# out: dictionary of dictionaries of objects containing all combinations of 
#     delete/modify/create and node/way/relation, using the osm_id as the key
#
# Identify parses the change file and generates an output of all objects specified in change file
# this output returned from this function is used to build the final output

def Identify(change_file, users):

    if users is None:
        users = []

    # parse change_file using XML parser
    change_tree = ElementTree.parse(change_file)
    change_root = change_tree.getroot()

    # dictionaries use osm feature id as key and contain and way/node/relation data as the value
    delete_nodes = {}
    delete_ways = {}
    delete_relations = {}
    modify_nodes = {}
    modify_ways = {}
    modify_relations = {}
    create_nodes = {}
    create_ways = {}
    create_relations = {}
    # needed_nodes is used to identify nodes from ways that are required but not included in the change_file
    # the old osm file is used to include these nodes
    needed_nodes = {}
    
    # process all objects in 'delete' tree
    for child in change_root.findall('delete'):
        for node in child.findall('node'):
            #node.append(Element('tag', {'k':'change', 'v':'delete'}))
	    delete_nodes[node.attrib['id']] = node
        
        for way in child.findall('way'):
            way.append(Element('tag', {'k':'change', 'v':'delete'}))
            for sub_element in way.findall('nd'):
                needed_nodes[sub_element.attrib['ref']] = sub_element.attrib['ref']
            delete_ways[way.attrib['id']] = way

        for relation in child.findall('relation'):
            relation.append(Element('tag', {'k':'change', 'v':'delete'}))
            delete_relations[relation.attrib['id']] = relation

    # process all objects in 'modify' tree
    for child in change_root.findall('modify'):
        for node in child.findall('node'):
            if(node.attrib['user'] not in users):
                #node.append(Element('tag', {'k':'change', 'v':'modify'}))
	        modify_nodes[node.attrib['id']] = node
        
        for way in child.findall('way'):
            if(way.attrib['user'] not in users):
                way.append(Element('tag', {'k':'change', 'v':'modify'}))
                for sub_element in way.findall('nd'):
                    needed_nodes[sub_element.attrib['ref']] = sub_element.attrib['ref']
	        modify_ways[way.attrib['id']] = way

        for relation in child.findall('relation'):
            if(relation.attrib['user'] not in users):
                relation.append(Element('tag', {'k':'change', 'v':'modify'}))
                modify_relations[relation.attrib['id']] = relation

    # process all objects in 'create' tree
    for child in change_root.findall('create'):
        for node in child.findall('node'):
            if(node.attrib['user'] not in users):
	        #node.append(Element('tag', {'k':'change', 'v':'create'}))
                create_nodes[node.attrib['id']] = node

        for way in child.findall('way'):
            if(way.attrib['user'] not in users):
	        way.append(Element('tag', {'k':'change', 'v':'create'}))
                for sub_element in way.findall('nd'):
                    needed_nodes[sub_element.attrib['ref']] = sub_element.attrib['ref']
                create_ways[way.attrib['id']] = way
        
        for relation in child.findall('relation'):
            if(relation.attrib['user'] not in users):
	        relation.append(Element('tag', {'k':'change', 'v':'create'}))
                create_relations[relation.attrib['id']] = relation

    return {'delete_nodes':delete_nodes, \
            'delete_ways':delete_ways, \
            'delete_relations':delete_relations, \
            'modify_nodes':modify_nodes, \
            'modify_ways':modify_ways, \
            'modify_relations':modify_relations, \
            'create_nodes':create_nodes, \
            'create_ways':create_ways, \
            'create_relations':create_relations, \
            'needed_nodes':needed_nodes}


# Function New_Tree(old_root)
#
# in: root for old_osm file from ElementTree getroot() method
# out: new xml tree with headers and declarations from old_osm file

def New_Tree(old_root):
    new_root = Element('osm')
    new_root.set('version', old_root.attrib['version'])

    # some programs output either 'bounds' or 'bound'
    try:
        new_root.append(old_root.find('bounds'))
    except:
        new_root.append(old_root.find('bound'))

    return ElementTree.ElementTree(new_root)


# Function Build(results, old_file, out_file)
#
# in: results - output returned from 'Identify' function
#     old_file - old osm file that was used to generate change file
#     out_file - file path and name for final osm file output
#
# Build searches old_file for nodes and ways that have been modified or deleted
# from the old osm and adds the new version to the output. 
# It also includes features that have been newly created.

def Build(results, old_file, out_file):
    old_tree = ElementTree.parse(old_file)
    old_root = old_tree.getroot()

    # generate new_tree with old osm file headers and declarations
    new_tree = New_Tree(old_root)
    new_root = new_tree.getroot()

    delete_nodes = results['delete_nodes']
    delete_ways = results['delete_ways']
    modify_nodes = results['modify_nodes']
    modify_ways = results['modify_ways']
    create_nodes = results['create_nodes']
    create_ways = results['create_ways']
    needed_nodes = results['needed_nodes']


    # TODO check if matching to delete_nodes and modify_nodes is necessary?
    for node in old_root.findall('node'):
        match = node.attrib['id']
        if match in delete_nodes:
            new_root.append(delete_nodes[match])
        elif match in modify_nodes:
            new_root.append(modify_nodes[match])
        elif match in needed_nodes:
            #node.append(Element('tag', {'k':'change', 'v':'false'}))
            new_root.append(node)


    # TODO check if matching to delete_ways and modify_ways is necessary?
    for way in old_root.findall('way'):
        match = way.attrib['id']
        if match in delete_ways:
            new_root.append(delete_ways[match])
        elif match in modify_ways:
            new_root.append(modify_ways[match])
        

    # add newly created features
    for node in create_nodes.keys():
        new_root.append(create_nodes[node])
    for way in create_ways.keys():
        new_root.append(create_ways[way])

    

    # create final output 
    new_tree.write(out_file, xml_declaration=True, encoding="utf-8", method="xml")

